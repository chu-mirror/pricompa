# Pricompa (priconne companion)

_Pricompa_ is an auxiliary tool for game _priconne_, the major functionality
is an auto clicker but designed perticularly for game playing.  More
funcationalities, like time-line recorder or status monitor, are planned,
but the developer is not sure when to do these stuffs.

This project uses C and CMake, as a Win32 application usually is.

@[CMakeLists.txt@]
cmake_minimum_required(VERSION 3.2)
project(Pricompa LANGUAGES C)
add_executable(pricompa pricompa.c)
@

@[pricompa.c@]
@{includes@}
@{data@}
@{prototypes@}
@{functions@}
@


## Main loop and Basic style

Main loop is fairly straight forward.

@[functions@]
int
main(int argn, char *argv[])
{
	@{initialize environment@}
	@{receive and dispatch events@}
	@{do cleaning@}
}
@

The program is built upon Win32 API, but do not use utf-16.

@[includes@]
#undef _UNICODE
#include <windows.h>
@

@[receive and dispatch events@]
{
	MSG msg;
	BOOL bRet;
	while ((bRet = GetMessage(&msg, NULL, 0, 0)) > 0) {
		switch (msg.message) {
			@{event handlers@}
		}
	}
	if (bRet == -1) { /* something wrong */
		@{handle error in GetMessage@}
	}
}
@

Since I do not want to handle error messages in Windows way, neither the management
of memory, so prepare a buffer to transfer error messages.
@[data@]
#define MAXMSG 2048
char errmsg[2048];
@

@[initialize environment@]
errmsg[MAXMSG-1] = '\0';
@

And the corresponding procedures for saving error massage to _errmsg_.
@[functions@]
void
get_sys_errmsg()
{
	DWORD eno, msglen;
	LPTSTR pmsg;
	
	eno = GetLastError();
	msglen = FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, eno,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
		(LPTSTR) &pmsg, 0, NULL);
	if (msglen >= MAXMSG) {
		info("fatal error: error massage is too long");
		exit(1);
	} else if (msglen > 0) {
		sprintf(errmsg, "%s", (char *)pmsg);
	} else {
		sprintf(errmsg, "the error number: %d", eno);
	}
}

void
get_nonsys_errmsg(const char *msg)
{
	if (strlen(msg) >= MAXMSG) {
		info("fatal error: error massage is too long");
		exit(1);
	} else {
		sprintf(errmsg, msg);
	}
}
@

@[prototypes@]
void get_sys_errmsg(void);
void get_nonsys_errmsg(const char *);
@

The error handling is also straight forward.
@[handle error in GetMessage@]
get_sys_errmsg();
@{show error message@}
exit(1);
@

The program is a console application, users can suppose information prompted by
the console.  I simply use standard C library here.

@[includes@]
#include <stdio.h>
@

@[functions@]
void
info(const char *msg)
{
	printf("%s\n", msg);
}
@

@[prototypes@]
void info(const char *);
@

@[show error message@]
info(errmsg);
@

Use hotkeys to interact with _Pricompa_.

@[event handlers@]
case WM_HOTKEY:
	switch (msg.wParam) {
	@{hotkey handlers@}
	}
break;
@

Hotkeys' modifier is fixed to CTRL+SHIFT.
@[data@]
#define MOD (MOD_CONTROL | MOD_SHIFT | MOD_NOREPEAT)
@

The custom of exception handling is consistent through out the program.
	0: succeed
	1: known error, save massage to errmsg
	2: unknown error

@[functions@]
int
register_hotkey(char key, int id)
{
	if (RegisterHotKey(NULL, id, MOD, key-'A'+0x41)) {
		return 0;
	} else {
		get_sys_errmsg();
		return 1;
	}
}
@

@[prototypes@]
int register_hotkey(char, int);
@

## Interact with Game

Clicking are supposed to be the only officially supported way we send inputs to game,
but we need the clicks coming from hardware driver level.  _Pricompa_ uses
library [interception](https://github.com/oblitum/Interception)
to interact with game.  This library allows a process functioning as a filter
of device inputs.

@[CMakeLists.txt@]
target_link_libraries(pricompa
	@{libraries@}
)
@

@[includes@]
#include "interception.h"
@

All source and library files are placed under the same directory.
@[libraries@]
PRIVATE ${CMAKE_SOURCE_DIR}/interception.lib
@

To use this library, we need to declare some variables at first.
@[data@]
InterceptionContext context = NULL;
InterceptionDevice device;
@

To do clicking, we need a basic action of clicking once at purposed position,
since the game has a fixed layout, we can simply record these positions in an array.
@[data@]
typedef struct position {
	int x;
	int y;
} position;

position positions[200]; /* a magic number, but I don't want to waste time on it */
@

Because we use this library to send mouse input rather than to filter it, we should
construct input events ourselves.
@[data@]
InterceptionMouseStroke left_down, left_up;
@

@[initialize environment@]
left_down.state = INTERCEPTION_MOUSE_LEFT_BUTTON_DOWN;
left_up.state = INTERCEPTION_MOUSE_LEFT_BUTTON_UP;
@

@[functions@]
int
click_once()
{
	int left = 2;
	if (context == NULL) {
		get_nonsys_errmsg("have not initialize context");
		return 1;
	}
	left -= interception_send(context, INTERCEPTION_MOUSE(1), (InterceptionStroke *)&left_down, 1);
	Sleep(2);
	left -= interception_send(context, INTERCEPTION_MOUSE(1), (InterceptionStroke *)&left_up, 1);
	if (left == 0) {
		return 0;
	} else {
		get_nonsys_errmsg("failed to send one click");
		return 1;
	}
}
@

@[prototypes@]
int click_once(void);
@

## Auto Clicker

The hotkeys:
	CTRL+SHIFT+S	start/stop
@[data@]
#define AUTOCLICKER_SS 1
@

@[initialize environment@]
if (register_hotkey('S', AUTOCLICKER_SS)) {
	info(errmsg);
	exit(1);
}
@

The auto clicker is highly time-critical.
@[initialize environment@]
SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
@


@[hotkey handlers@]
case AUTOCLICKER_SS:
	if (context == NULL) {
		context = interception_create_context();
		@{start clicking@}
	} else {
		@{end clicking@}
		interception_destroy_context(context);
		context = NULL;
	}
@


The auto clicks are performed by a seperate thread.

@[data@]
HANDLE hClicker;
@

